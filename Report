Program 1: 
查看mandelbrot set的具体计算逻辑可知，每次task运行loop的次数是不一样的，亮点处需要大量循环而暗点处几乎瞬间执行完。
插入time record后可以看到：

view 1
threads = 2, 预期对半分
Hello world from thread 0, [102.555] ms
Hello world from thread 1, [104.532] ms
[mandelbrot thread]:		[102.241] ms
Wrote image file mandelbrot-thread.ppm
				(1.97x speedup from 2 threads)

threads = 3, 预期idx1任务量大
Hello world from thread 0, [40.951] ms
Hello world from thread 1, [125.207] ms
Hello world from thread 2, [41.255] ms
[mandelbrot thread]:		[124.376] ms
Wrote image file mandelbrot-thread.ppm
				(1.61x speedup from 3 threads)

threads = 4, 预期idx0=idx3, idx1=idx2, 且idx1/2任务量大
Hello world from thread 0, [19.046] ms
Hello world from thread 1, [82.858] ms
Hello world from thread 2, [83.741] ms
Hello world from thread 3, [20.153] ms
[mandelbrot thread]:		[83.813] ms
Wrote image file mandelbrot-thread.ppm
				(2.40x speedup from 4 threads)

而view 2任务比较均衡，相对来说加速效果较好。

预测和观察到的时间符合，结论是每个thread负责的任务量不一致，负载不均衡导致加速没有达到期望中的效果。

TODO: 找一个合适的分割使得view 1/2在threads=4时候的加速比都能达到3.5X

Program 2:
1. 给的abs example存在什么问题?
当 (N % VECTOR_WIDTH) != 0时， 最后一个iteration做_cmu418_vload_float(x, values+i, maskAll) 会访存越界。

2. size = 10000
width = 2
Vector Width:              2
Total Vector Instructions: 167727
Vector Utilization:        77.616901%
Utilized Vector Lanes:     260369
Total Vector Lanes:        335454

width = 4
Vector Width:              4
Total Vector Instructions: 97075
Vector Utilization:        70.457121%
Utilized Vector Lanes:     273585
Total Vector Lanes:        388300

width = 8
Vector Width:              8
Total Vector Instructions: 52877
Vector Utilization:        66.728682%
Utilized Vector Lanes:     282273
Total Vector Lanes:        423016

width = 16
Vector Width:              16
Total Vector Instructions: 27592
Vector Utilization:        64.988267%
Utilized Vector Lanes:     286905
Total Vector Lanes:        441472

可以看到Vector Utilization下降了，分析代码猜测是因为while循环的原因：while循环的次数是由width长度的data中最大的y决定的，其余早早降到0的y占用的lane都是额外的cost,所以width越长，就有越多lane被bound住越久。

Extra credit: Reduction by [0 1 2 3 4 5 6 7] hadd-> [1 1 5 5 9 9 13 13] interleave-> [1 5 9 13 1 5 9 13] maskHalf-> hadd loop